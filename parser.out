Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> exprs
Rule 2     exprs -> exprs expr
Rule 3     exprs -> expr
Rule 4     expr -> constants
Rule 5     expr -> functions
Rule 6     start -> constants functions
Rule 7     functions -> functions function
Rule 8     functions -> function
Rule 9     function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
Rule 10    function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
Rule 11    params -> STR LSQUARE RSQUARE ID
Rule 12    params -> empty
Rule 13    expressions -> expressions expression
Rule 14    expressions -> expression
Rule 15    expression -> constants
Rule 16    expression -> while
Rule 17    expression -> if
Rule 18    expression -> assigned
Rule 19    expression -> print
Rule 20    expression -> get
Rule 21    expression -> call
Rule 22    call -> ID LPAREN RPAREN SEMICOLON
Rule 23    assigned -> ID ASSIGN type SEMICOLON
Rule 24    while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
Rule 25    if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
Rule 26    if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
Rule 27    statement -> type logic_op type
Rule 28    logic_op -> EQ
Rule 29    logic_op -> NOT_EQ
Rule 30    logic_op -> GREATER
Rule 31    logic_op -> GREATER_EQ
Rule 32    logic_op -> LESS
Rule 33    logic_op -> LESS_EQ
Rule 34    variable -> var_type init SEMICOLON
Rule 35    init -> ID ASSIGN type
Rule 36    init -> ID
Rule 37    var_type -> INT
Rule 38    var_type -> STR
Rule 39    var_type -> BOOL
Rule 40    type -> NUMBER
Rule 41    type -> STRING
Rule 42    type -> boolean
Rule 43    type -> ID
Rule 44    boolean -> TRUE
Rule 45    boolean -> FALSE
Rule 46    constants -> constants constant
Rule 47    constants -> constants variable
Rule 48    constants -> constant
Rule 49    constants -> variable
Rule 50    constant -> ENUM init SEMICOLON
Rule 51    print -> WRITELN LPAREN type RPAREN SEMICOLON
Rule 52    get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
Rule 53    gets -> GET_INT
Rule 54    gets -> GET_STRING
Rule 55    gets -> GET_BOOL
Rule 56    empty -> <empty>
Rule 57    new_scope -> empty

Terminals, with rules where they appear

AMPERSAND            : 52
ASSIGN               : 23 35
BOOL                 : 39
COMMA                : 52
ELSE                 : 26
ENUM                 : 50
EQ                   : 28
FALSE                : 45
GET_BOOL             : 55
GET_INT              : 53
GET_STRING           : 54
GREATER              : 30
GREATER_EQ           : 31
ID                   : 9 10 11 22 23 35 36 43 52
IF                   : 25 26
INT                  : 37
LBRACE               : 9 10 24 25 26 26
LESS                 : 32
LESS_EQ              : 33
LPAREN               : 9 10 22 24 25 26 51 52
LSQUARE              : 11
NOT_EQ               : 29
NUMBER               : 40
RBRACE               : 9 10 24 25 26 26
READF                : 52
RPAREN               : 9 10 22 24 25 26 51 52
RSQUARE              : 11
SEMICOLON            : 22 23 34 50 51 52
STR                  : 11 38
STRING               : 41
TRUE                 : 44
VOID                 : 9 10
WHILE                : 24
WRITELN              : 51
error                : 

Nonterminals, with rules where they appear

assigned             : 18
boolean              : 42
call                 : 21
constant             : 46 48
constants            : 4 6 15 46 47
empty                : 12 57
expr                 : 2 3
expression           : 13 14
expressions          : 9 13 24 25 26 26
exprs                : 1 2
function             : 7 8
functions            : 5 6 7
get                  : 20
gets                 : 52
if                   : 17
init                 : 34 50
logic_op             : 27
new_scope            : 9 10 24 25 26 26
params               : 9 10
print                : 19
start                : 0
statement            : 24 25 26
type                 : 23 27 27 35 51
var_type             : 34
variable             : 47 49
while                : 16

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . exprs
    (6) start -> . constants functions
    (2) exprs -> . exprs expr
    (3) exprs -> . expr
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (4) expr -> . constants
    (5) expr -> . functions
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (7) functions -> . functions function
    (8) functions -> . function
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL
    (9) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (10) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (57) new_scope -> . empty
    (56) empty -> .

    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15
    VOID            reduce using rule 56 (empty -> .)

    function                       shift and go to state 8
    functions                      shift and go to state 4
    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    exprs                          shift and go to state 14
    expr                           shift and go to state 13
    new_scope                      shift and go to state 5
    start                          shift and go to state 6
    empty                          shift and go to state 7
    variable                       shift and go to state 10
    constants                      shift and go to state 11

state 1

    (48) constants -> constant .

    ENUM            reduce using rule 48 (constants -> constant .)
    INT             reduce using rule 48 (constants -> constant .)
    STR             reduce using rule 48 (constants -> constant .)
    BOOL            reduce using rule 48 (constants -> constant .)
    RBRACE          reduce using rule 48 (constants -> constant .)
    WHILE           reduce using rule 48 (constants -> constant .)
    IF              reduce using rule 48 (constants -> constant .)
    ID              reduce using rule 48 (constants -> constant .)
    WRITELN         reduce using rule 48 (constants -> constant .)
    READF           reduce using rule 48 (constants -> constant .)
    VOID            reduce using rule 48 (constants -> constant .)
    $end            reduce using rule 48 (constants -> constant .)


state 2

    (38) var_type -> STR .

    ID              reduce using rule 38 (var_type -> STR .)


state 3

    (34) variable -> var_type . init SEMICOLON
    (35) init -> . ID ASSIGN type
    (36) init -> . ID

    ID              shift and go to state 16

    init                           shift and go to state 17

state 4

    (5) expr -> functions .
    (7) functions -> functions . function
    (9) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (10) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (57) new_scope -> . empty
    (56) empty -> .

  ! reduce/reduce conflict for VOID resolved using rule 5 (expr -> functions .)
    ENUM            reduce using rule 5 (expr -> functions .)
    INT             reduce using rule 5 (expr -> functions .)
    STR             reduce using rule 5 (expr -> functions .)
    BOOL            reduce using rule 5 (expr -> functions .)
    VOID            reduce using rule 5 (expr -> functions .)
    $end            reduce using rule 5 (expr -> functions .)

  ! VOID            [ reduce using rule 56 (empty -> .) ]

    function                       shift and go to state 18
    new_scope                      shift and go to state 5
    empty                          shift and go to state 7

state 5

    (9) function -> new_scope . VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (10) function -> new_scope . VOID ID LPAREN params RPAREN LBRACE RBRACE

    VOID            shift and go to state 19


state 6

    (0) S' -> start .



state 7

    (57) new_scope -> empty .

    VOID            reduce using rule 57 (new_scope -> empty .)
    WHILE           reduce using rule 57 (new_scope -> empty .)
    IF              reduce using rule 57 (new_scope -> empty .)
    ID              reduce using rule 57 (new_scope -> empty .)
    WRITELN         reduce using rule 57 (new_scope -> empty .)
    READF           reduce using rule 57 (new_scope -> empty .)
    ENUM            reduce using rule 57 (new_scope -> empty .)
    INT             reduce using rule 57 (new_scope -> empty .)
    STR             reduce using rule 57 (new_scope -> empty .)
    BOOL            reduce using rule 57 (new_scope -> empty .)


state 8

    (8) functions -> function .

    VOID            reduce using rule 8 (functions -> function .)
    $end            reduce using rule 8 (functions -> function .)
    ENUM            reduce using rule 8 (functions -> function .)
    INT             reduce using rule 8 (functions -> function .)
    STR             reduce using rule 8 (functions -> function .)
    BOOL            reduce using rule 8 (functions -> function .)


state 9

    (50) constant -> ENUM . init SEMICOLON
    (35) init -> . ID ASSIGN type
    (36) init -> . ID

    ID              shift and go to state 16

    init                           shift and go to state 20

state 10

    (49) constants -> variable .

    ENUM            reduce using rule 49 (constants -> variable .)
    INT             reduce using rule 49 (constants -> variable .)
    STR             reduce using rule 49 (constants -> variable .)
    BOOL            reduce using rule 49 (constants -> variable .)
    RBRACE          reduce using rule 49 (constants -> variable .)
    WHILE           reduce using rule 49 (constants -> variable .)
    IF              reduce using rule 49 (constants -> variable .)
    ID              reduce using rule 49 (constants -> variable .)
    WRITELN         reduce using rule 49 (constants -> variable .)
    READF           reduce using rule 49 (constants -> variable .)
    VOID            reduce using rule 49 (constants -> variable .)
    $end            reduce using rule 49 (constants -> variable .)


state 11

    (6) start -> constants . functions
    (46) constants -> constants . constant
    (47) constants -> constants . variable
    (4) expr -> constants .
    (7) functions -> . functions function
    (8) functions -> . function
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (9) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (10) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL
    (57) new_scope -> . empty
    (56) empty -> .

  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! reduce/reduce conflict for VOID resolved using rule 4 (expr -> constants .)
    VOID            reduce using rule 4 (expr -> constants .)
    $end            reduce using rule 4 (expr -> constants .)
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

  ! ENUM            [ reduce using rule 4 (expr -> constants .) ]
  ! INT             [ reduce using rule 4 (expr -> constants .) ]
  ! STR             [ reduce using rule 4 (expr -> constants .) ]
  ! BOOL            [ reduce using rule 4 (expr -> constants .) ]
  ! VOID            [ reduce using rule 56 (empty -> .) ]

    function                       shift and go to state 8
    functions                      shift and go to state 22
    constant                       shift and go to state 21
    var_type                       shift and go to state 3
    new_scope                      shift and go to state 5
    empty                          shift and go to state 7
    variable                       shift and go to state 23

state 12

    (37) var_type -> INT .

    ID              reduce using rule 37 (var_type -> INT .)


state 13

    (3) exprs -> expr .

    ENUM            reduce using rule 3 (exprs -> expr .)
    INT             reduce using rule 3 (exprs -> expr .)
    STR             reduce using rule 3 (exprs -> expr .)
    BOOL            reduce using rule 3 (exprs -> expr .)
    VOID            reduce using rule 3 (exprs -> expr .)
    $end            reduce using rule 3 (exprs -> expr .)


state 14

    (1) start -> exprs .
    (2) exprs -> exprs . expr
    (4) expr -> . constants
    (5) expr -> . functions
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (7) functions -> . functions function
    (8) functions -> . function
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (9) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (10) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL
    (57) new_scope -> . empty
    (56) empty -> .

    $end            reduce using rule 1 (start -> exprs .)
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15
    VOID            reduce using rule 56 (empty -> .)

    function                       shift and go to state 8
    functions                      shift and go to state 4
    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    expr                           shift and go to state 25
    new_scope                      shift and go to state 5
    empty                          shift and go to state 7
    variable                       shift and go to state 10
    constants                      shift and go to state 24

state 15

    (39) var_type -> BOOL .

    ID              reduce using rule 39 (var_type -> BOOL .)


state 16

    (35) init -> ID . ASSIGN type
    (36) init -> ID .

    ASSIGN          shift and go to state 26
    SEMICOLON       reduce using rule 36 (init -> ID .)


state 17

    (34) variable -> var_type init . SEMICOLON

    SEMICOLON       shift and go to state 27


state 18

    (7) functions -> functions function .

    VOID            reduce using rule 7 (functions -> functions function .)
    $end            reduce using rule 7 (functions -> functions function .)
    ENUM            reduce using rule 7 (functions -> functions function .)
    INT             reduce using rule 7 (functions -> functions function .)
    STR             reduce using rule 7 (functions -> functions function .)
    BOOL            reduce using rule 7 (functions -> functions function .)


state 19

    (9) function -> new_scope VOID . ID LPAREN params RPAREN LBRACE expressions RBRACE
    (10) function -> new_scope VOID . ID LPAREN params RPAREN LBRACE RBRACE

    ID              shift and go to state 28


state 20

    (50) constant -> ENUM init . SEMICOLON

    SEMICOLON       shift and go to state 29


state 21

    (46) constants -> constants constant .

    ENUM            reduce using rule 46 (constants -> constants constant .)
    INT             reduce using rule 46 (constants -> constants constant .)
    STR             reduce using rule 46 (constants -> constants constant .)
    BOOL            reduce using rule 46 (constants -> constants constant .)
    RBRACE          reduce using rule 46 (constants -> constants constant .)
    WHILE           reduce using rule 46 (constants -> constants constant .)
    IF              reduce using rule 46 (constants -> constants constant .)
    ID              reduce using rule 46 (constants -> constants constant .)
    WRITELN         reduce using rule 46 (constants -> constants constant .)
    READF           reduce using rule 46 (constants -> constants constant .)
    VOID            reduce using rule 46 (constants -> constants constant .)
    $end            reduce using rule 46 (constants -> constants constant .)


state 22

    (6) start -> constants functions .
    (7) functions -> functions . function
    (9) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (10) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (57) new_scope -> . empty
    (56) empty -> .

    $end            reduce using rule 6 (start -> constants functions .)
    VOID            reduce using rule 56 (empty -> .)

    function                       shift and go to state 18
    new_scope                      shift and go to state 5
    empty                          shift and go to state 7

state 23

    (47) constants -> constants variable .

    ENUM            reduce using rule 47 (constants -> constants variable .)
    INT             reduce using rule 47 (constants -> constants variable .)
    STR             reduce using rule 47 (constants -> constants variable .)
    BOOL            reduce using rule 47 (constants -> constants variable .)
    RBRACE          reduce using rule 47 (constants -> constants variable .)
    WHILE           reduce using rule 47 (constants -> constants variable .)
    IF              reduce using rule 47 (constants -> constants variable .)
    ID              reduce using rule 47 (constants -> constants variable .)
    WRITELN         reduce using rule 47 (constants -> constants variable .)
    READF           reduce using rule 47 (constants -> constants variable .)
    VOID            reduce using rule 47 (constants -> constants variable .)
    $end            reduce using rule 47 (constants -> constants variable .)


state 24

    (4) expr -> constants .
    (46) constants -> constants . constant
    (47) constants -> constants . variable
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
    VOID            reduce using rule 4 (expr -> constants .)
    $end            reduce using rule 4 (expr -> constants .)
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

  ! ENUM            [ reduce using rule 4 (expr -> constants .) ]
  ! INT             [ reduce using rule 4 (expr -> constants .) ]
  ! STR             [ reduce using rule 4 (expr -> constants .) ]
  ! BOOL            [ reduce using rule 4 (expr -> constants .) ]

    variable                       shift and go to state 23
    constant                       shift and go to state 21
    var_type                       shift and go to state 3

state 25

    (2) exprs -> exprs expr .

    ENUM            reduce using rule 2 (exprs -> exprs expr .)
    INT             reduce using rule 2 (exprs -> exprs expr .)
    STR             reduce using rule 2 (exprs -> exprs expr .)
    BOOL            reduce using rule 2 (exprs -> exprs expr .)
    VOID            reduce using rule 2 (exprs -> exprs expr .)
    $end            reduce using rule 2 (exprs -> exprs expr .)


state 26

    (35) init -> ID ASSIGN . type
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . boolean
    (43) type -> . ID
    (44) boolean -> . TRUE
    (45) boolean -> . FALSE

    NUMBER          shift and go to state 33
    STRING          shift and go to state 31
    ID              shift and go to state 36
    TRUE            shift and go to state 32
    FALSE           shift and go to state 30

    boolean                        shift and go to state 34
    type                           shift and go to state 35

state 27

    (34) variable -> var_type init SEMICOLON .

    ENUM            reduce using rule 34 (variable -> var_type init SEMICOLON .)
    INT             reduce using rule 34 (variable -> var_type init SEMICOLON .)
    STR             reduce using rule 34 (variable -> var_type init SEMICOLON .)
    BOOL            reduce using rule 34 (variable -> var_type init SEMICOLON .)
    RBRACE          reduce using rule 34 (variable -> var_type init SEMICOLON .)
    WHILE           reduce using rule 34 (variable -> var_type init SEMICOLON .)
    IF              reduce using rule 34 (variable -> var_type init SEMICOLON .)
    ID              reduce using rule 34 (variable -> var_type init SEMICOLON .)
    WRITELN         reduce using rule 34 (variable -> var_type init SEMICOLON .)
    READF           reduce using rule 34 (variable -> var_type init SEMICOLON .)
    VOID            reduce using rule 34 (variable -> var_type init SEMICOLON .)
    $end            reduce using rule 34 (variable -> var_type init SEMICOLON .)


state 28

    (9) function -> new_scope VOID ID . LPAREN params RPAREN LBRACE expressions RBRACE
    (10) function -> new_scope VOID ID . LPAREN params RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 37


state 29

    (50) constant -> ENUM init SEMICOLON .

    ENUM            reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    INT             reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    STR             reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    BOOL            reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    RBRACE          reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    WHILE           reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    IF              reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    ID              reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    WRITELN         reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    READF           reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    VOID            reduce using rule 50 (constant -> ENUM init SEMICOLON .)
    $end            reduce using rule 50 (constant -> ENUM init SEMICOLON .)


state 30

    (45) boolean -> FALSE .

    SEMICOLON       reduce using rule 45 (boolean -> FALSE .)
    RPAREN          reduce using rule 45 (boolean -> FALSE .)
    EQ              reduce using rule 45 (boolean -> FALSE .)
    NOT_EQ          reduce using rule 45 (boolean -> FALSE .)
    GREATER         reduce using rule 45 (boolean -> FALSE .)
    GREATER_EQ      reduce using rule 45 (boolean -> FALSE .)
    LESS            reduce using rule 45 (boolean -> FALSE .)
    LESS_EQ         reduce using rule 45 (boolean -> FALSE .)


state 31

    (41) type -> STRING .

    EQ              reduce using rule 41 (type -> STRING .)
    NOT_EQ          reduce using rule 41 (type -> STRING .)
    GREATER         reduce using rule 41 (type -> STRING .)
    GREATER_EQ      reduce using rule 41 (type -> STRING .)
    LESS            reduce using rule 41 (type -> STRING .)
    LESS_EQ         reduce using rule 41 (type -> STRING .)
    RPAREN          reduce using rule 41 (type -> STRING .)
    SEMICOLON       reduce using rule 41 (type -> STRING .)


state 32

    (44) boolean -> TRUE .

    SEMICOLON       reduce using rule 44 (boolean -> TRUE .)
    RPAREN          reduce using rule 44 (boolean -> TRUE .)
    EQ              reduce using rule 44 (boolean -> TRUE .)
    NOT_EQ          reduce using rule 44 (boolean -> TRUE .)
    GREATER         reduce using rule 44 (boolean -> TRUE .)
    GREATER_EQ      reduce using rule 44 (boolean -> TRUE .)
    LESS            reduce using rule 44 (boolean -> TRUE .)
    LESS_EQ         reduce using rule 44 (boolean -> TRUE .)


state 33

    (40) type -> NUMBER .

    EQ              reduce using rule 40 (type -> NUMBER .)
    NOT_EQ          reduce using rule 40 (type -> NUMBER .)
    GREATER         reduce using rule 40 (type -> NUMBER .)
    GREATER_EQ      reduce using rule 40 (type -> NUMBER .)
    LESS            reduce using rule 40 (type -> NUMBER .)
    LESS_EQ         reduce using rule 40 (type -> NUMBER .)
    RPAREN          reduce using rule 40 (type -> NUMBER .)
    SEMICOLON       reduce using rule 40 (type -> NUMBER .)


state 34

    (42) type -> boolean .

    EQ              reduce using rule 42 (type -> boolean .)
    NOT_EQ          reduce using rule 42 (type -> boolean .)
    GREATER         reduce using rule 42 (type -> boolean .)
    GREATER_EQ      reduce using rule 42 (type -> boolean .)
    LESS            reduce using rule 42 (type -> boolean .)
    LESS_EQ         reduce using rule 42 (type -> boolean .)
    RPAREN          reduce using rule 42 (type -> boolean .)
    SEMICOLON       reduce using rule 42 (type -> boolean .)


state 35

    (35) init -> ID ASSIGN type .

    SEMICOLON       reduce using rule 35 (init -> ID ASSIGN type .)


state 36

    (43) type -> ID .

    EQ              reduce using rule 43 (type -> ID .)
    NOT_EQ          reduce using rule 43 (type -> ID .)
    GREATER         reduce using rule 43 (type -> ID .)
    GREATER_EQ      reduce using rule 43 (type -> ID .)
    LESS            reduce using rule 43 (type -> ID .)
    LESS_EQ         reduce using rule 43 (type -> ID .)
    RPAREN          reduce using rule 43 (type -> ID .)
    SEMICOLON       reduce using rule 43 (type -> ID .)


state 37

    (9) function -> new_scope VOID ID LPAREN . params RPAREN LBRACE expressions RBRACE
    (10) function -> new_scope VOID ID LPAREN . params RPAREN LBRACE RBRACE
    (11) params -> . STR LSQUARE RSQUARE ID
    (12) params -> . empty
    (56) empty -> .

    STR             shift and go to state 38
    RPAREN          reduce using rule 56 (empty -> .)

    params                         shift and go to state 39
    empty                          shift and go to state 40

state 38

    (11) params -> STR . LSQUARE RSQUARE ID

    LSQUARE         shift and go to state 41


state 39

    (9) function -> new_scope VOID ID LPAREN params . RPAREN LBRACE expressions RBRACE
    (10) function -> new_scope VOID ID LPAREN params . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 42


state 40

    (12) params -> empty .

    RPAREN          reduce using rule 12 (params -> empty .)


state 41

    (11) params -> STR LSQUARE . RSQUARE ID

    RSQUARE         shift and go to state 43


state 42

    (9) function -> new_scope VOID ID LPAREN params RPAREN . LBRACE expressions RBRACE
    (10) function -> new_scope VOID ID LPAREN params RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 44


state 43

    (11) params -> STR LSQUARE RSQUARE . ID

    ID              shift and go to state 45


state 44

    (9) function -> new_scope VOID ID LPAREN params RPAREN LBRACE . expressions RBRACE
    (10) function -> new_scope VOID ID LPAREN params RPAREN LBRACE . RBRACE
    (13) expressions -> . expressions expression
    (14) expressions -> . expression
    (15) expression -> . constants
    (16) expression -> . while
    (17) expression -> . if
    (18) expression -> . assigned
    (19) expression -> . print
    (20) expression -> . get
    (21) expression -> . call
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (24) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (25) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) assigned -> . ID ASSIGN type SEMICOLON
    (51) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (52) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (22) call -> . ID LPAREN RPAREN SEMICOLON
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

    RBRACE          shift and go to state 52
    WHILE           shift and go to state 47
    IF              shift and go to state 57
    ID              shift and go to state 55
    WRITELN         shift and go to state 54
    READF           shift and go to state 58
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 53
    assigned                       shift and go to state 46
    variable                       shift and go to state 10
    while                          shift and go to state 59
    print                          shift and go to state 50
    call                           shift and go to state 51
    expressions                    shift and go to state 48
    expression                     shift and go to state 60
    constants                      shift and go to state 56
    if                             shift and go to state 49

state 45

    (11) params -> STR LSQUARE RSQUARE ID .

    RPAREN          reduce using rule 11 (params -> STR LSQUARE RSQUARE ID .)


state 46

    (18) expression -> assigned .

    RBRACE          reduce using rule 18 (expression -> assigned .)
    WHILE           reduce using rule 18 (expression -> assigned .)
    IF              reduce using rule 18 (expression -> assigned .)
    ID              reduce using rule 18 (expression -> assigned .)
    WRITELN         reduce using rule 18 (expression -> assigned .)
    READF           reduce using rule 18 (expression -> assigned .)
    ENUM            reduce using rule 18 (expression -> assigned .)
    INT             reduce using rule 18 (expression -> assigned .)
    STR             reduce using rule 18 (expression -> assigned .)
    BOOL            reduce using rule 18 (expression -> assigned .)


state 47

    (24) while -> WHILE . LPAREN statement RPAREN LBRACE new_scope expressions RBRACE

    LPAREN          shift and go to state 61


state 48

    (9) function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions . RBRACE
    (13) expressions -> expressions . expression
    (15) expression -> . constants
    (16) expression -> . while
    (17) expression -> . if
    (18) expression -> . assigned
    (19) expression -> . print
    (20) expression -> . get
    (21) expression -> . call
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (24) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (25) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) assigned -> . ID ASSIGN type SEMICOLON
    (51) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (52) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (22) call -> . ID LPAREN RPAREN SEMICOLON
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

    RBRACE          shift and go to state 62
    WHILE           shift and go to state 47
    IF              shift and go to state 57
    ID              shift and go to state 55
    WRITELN         shift and go to state 54
    READF           shift and go to state 58
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 53
    assigned                       shift and go to state 46
    variable                       shift and go to state 10
    while                          shift and go to state 59
    print                          shift and go to state 50
    call                           shift and go to state 51
    expression                     shift and go to state 63
    constants                      shift and go to state 56
    if                             shift and go to state 49

state 49

    (17) expression -> if .

    RBRACE          reduce using rule 17 (expression -> if .)
    WHILE           reduce using rule 17 (expression -> if .)
    IF              reduce using rule 17 (expression -> if .)
    ID              reduce using rule 17 (expression -> if .)
    WRITELN         reduce using rule 17 (expression -> if .)
    READF           reduce using rule 17 (expression -> if .)
    ENUM            reduce using rule 17 (expression -> if .)
    INT             reduce using rule 17 (expression -> if .)
    STR             reduce using rule 17 (expression -> if .)
    BOOL            reduce using rule 17 (expression -> if .)


state 50

    (19) expression -> print .

    RBRACE          reduce using rule 19 (expression -> print .)
    WHILE           reduce using rule 19 (expression -> print .)
    IF              reduce using rule 19 (expression -> print .)
    ID              reduce using rule 19 (expression -> print .)
    WRITELN         reduce using rule 19 (expression -> print .)
    READF           reduce using rule 19 (expression -> print .)
    ENUM            reduce using rule 19 (expression -> print .)
    INT             reduce using rule 19 (expression -> print .)
    STR             reduce using rule 19 (expression -> print .)
    BOOL            reduce using rule 19 (expression -> print .)


state 51

    (21) expression -> call .

    RBRACE          reduce using rule 21 (expression -> call .)
    WHILE           reduce using rule 21 (expression -> call .)
    IF              reduce using rule 21 (expression -> call .)
    ID              reduce using rule 21 (expression -> call .)
    WRITELN         reduce using rule 21 (expression -> call .)
    READF           reduce using rule 21 (expression -> call .)
    ENUM            reduce using rule 21 (expression -> call .)
    INT             reduce using rule 21 (expression -> call .)
    STR             reduce using rule 21 (expression -> call .)
    BOOL            reduce using rule 21 (expression -> call .)


state 52

    (10) function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .

    VOID            reduce using rule 10 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .)
    $end            reduce using rule 10 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .)
    ENUM            reduce using rule 10 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .)
    INT             reduce using rule 10 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .)
    STR             reduce using rule 10 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .)
    BOOL            reduce using rule 10 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .)


state 53

    (20) expression -> get .

    RBRACE          reduce using rule 20 (expression -> get .)
    WHILE           reduce using rule 20 (expression -> get .)
    IF              reduce using rule 20 (expression -> get .)
    ID              reduce using rule 20 (expression -> get .)
    WRITELN         reduce using rule 20 (expression -> get .)
    READF           reduce using rule 20 (expression -> get .)
    ENUM            reduce using rule 20 (expression -> get .)
    INT             reduce using rule 20 (expression -> get .)
    STR             reduce using rule 20 (expression -> get .)
    BOOL            reduce using rule 20 (expression -> get .)


state 54

    (51) print -> WRITELN . LPAREN type RPAREN SEMICOLON

    LPAREN          shift and go to state 64


state 55

    (23) assigned -> ID . ASSIGN type SEMICOLON
    (22) call -> ID . LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 65
    LPAREN          shift and go to state 66


state 56

    (15) expression -> constants .
    (46) constants -> constants . constant
    (47) constants -> constants . variable
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
    RBRACE          reduce using rule 15 (expression -> constants .)
    WHILE           reduce using rule 15 (expression -> constants .)
    IF              reduce using rule 15 (expression -> constants .)
    ID              reduce using rule 15 (expression -> constants .)
    WRITELN         reduce using rule 15 (expression -> constants .)
    READF           reduce using rule 15 (expression -> constants .)
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

  ! ENUM            [ reduce using rule 15 (expression -> constants .) ]
  ! INT             [ reduce using rule 15 (expression -> constants .) ]
  ! STR             [ reduce using rule 15 (expression -> constants .) ]
  ! BOOL            [ reduce using rule 15 (expression -> constants .) ]

    variable                       shift and go to state 23
    constant                       shift and go to state 21
    var_type                       shift and go to state 3

state 57

    (25) if -> IF . LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> IF . LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE

    LPAREN          shift and go to state 67


state 58

    (52) get -> READF . LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON

    LPAREN          shift and go to state 68


state 59

    (16) expression -> while .

    RBRACE          reduce using rule 16 (expression -> while .)
    WHILE           reduce using rule 16 (expression -> while .)
    IF              reduce using rule 16 (expression -> while .)
    ID              reduce using rule 16 (expression -> while .)
    WRITELN         reduce using rule 16 (expression -> while .)
    READF           reduce using rule 16 (expression -> while .)
    ENUM            reduce using rule 16 (expression -> while .)
    INT             reduce using rule 16 (expression -> while .)
    STR             reduce using rule 16 (expression -> while .)
    BOOL            reduce using rule 16 (expression -> while .)


state 60

    (14) expressions -> expression .

    RBRACE          reduce using rule 14 (expressions -> expression .)
    WHILE           reduce using rule 14 (expressions -> expression .)
    IF              reduce using rule 14 (expressions -> expression .)
    ID              reduce using rule 14 (expressions -> expression .)
    WRITELN         reduce using rule 14 (expressions -> expression .)
    READF           reduce using rule 14 (expressions -> expression .)
    ENUM            reduce using rule 14 (expressions -> expression .)
    INT             reduce using rule 14 (expressions -> expression .)
    STR             reduce using rule 14 (expressions -> expression .)
    BOOL            reduce using rule 14 (expressions -> expression .)


state 61

    (24) while -> WHILE LPAREN . statement RPAREN LBRACE new_scope expressions RBRACE
    (27) statement -> . type logic_op type
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . boolean
    (43) type -> . ID
    (44) boolean -> . TRUE
    (45) boolean -> . FALSE

    NUMBER          shift and go to state 33
    STRING          shift and go to state 31
    ID              shift and go to state 36
    TRUE            shift and go to state 32
    FALSE           shift and go to state 30

    boolean                        shift and go to state 34
    statement                      shift and go to state 69
    type                           shift and go to state 70

state 62

    (9) function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .

    VOID            reduce using rule 9 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .)
    $end            reduce using rule 9 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .)
    ENUM            reduce using rule 9 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .)
    INT             reduce using rule 9 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .)
    STR             reduce using rule 9 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .)
    BOOL            reduce using rule 9 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .)


state 63

    (13) expressions -> expressions expression .

    RBRACE          reduce using rule 13 (expressions -> expressions expression .)
    WHILE           reduce using rule 13 (expressions -> expressions expression .)
    IF              reduce using rule 13 (expressions -> expressions expression .)
    ID              reduce using rule 13 (expressions -> expressions expression .)
    WRITELN         reduce using rule 13 (expressions -> expressions expression .)
    READF           reduce using rule 13 (expressions -> expressions expression .)
    ENUM            reduce using rule 13 (expressions -> expressions expression .)
    INT             reduce using rule 13 (expressions -> expressions expression .)
    STR             reduce using rule 13 (expressions -> expressions expression .)
    BOOL            reduce using rule 13 (expressions -> expressions expression .)


state 64

    (51) print -> WRITELN LPAREN . type RPAREN SEMICOLON
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . boolean
    (43) type -> . ID
    (44) boolean -> . TRUE
    (45) boolean -> . FALSE

    NUMBER          shift and go to state 33
    STRING          shift and go to state 31
    ID              shift and go to state 36
    TRUE            shift and go to state 32
    FALSE           shift and go to state 30

    boolean                        shift and go to state 34
    type                           shift and go to state 71

state 65

    (23) assigned -> ID ASSIGN . type SEMICOLON
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . boolean
    (43) type -> . ID
    (44) boolean -> . TRUE
    (45) boolean -> . FALSE

    NUMBER          shift and go to state 33
    STRING          shift and go to state 31
    ID              shift and go to state 36
    TRUE            shift and go to state 32
    FALSE           shift and go to state 30

    boolean                        shift and go to state 34
    type                           shift and go to state 72

state 66

    (22) call -> ID LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 73


state 67

    (25) if -> IF LPAREN . statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> IF LPAREN . statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (27) statement -> . type logic_op type
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . boolean
    (43) type -> . ID
    (44) boolean -> . TRUE
    (45) boolean -> . FALSE

    NUMBER          shift and go to state 33
    STRING          shift and go to state 31
    ID              shift and go to state 36
    TRUE            shift and go to state 32
    FALSE           shift and go to state 30

    boolean                        shift and go to state 34
    statement                      shift and go to state 74
    type                           shift and go to state 70

state 68

    (52) get -> READF LPAREN . gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (53) gets -> . GET_INT
    (54) gets -> . GET_STRING
    (55) gets -> . GET_BOOL

    GET_INT         shift and go to state 77
    GET_STRING      shift and go to state 76
    GET_BOOL        shift and go to state 75

    gets                           shift and go to state 78

state 69

    (24) while -> WHILE LPAREN statement . RPAREN LBRACE new_scope expressions RBRACE

    RPAREN          shift and go to state 79


state 70

    (27) statement -> type . logic_op type
    (28) logic_op -> . EQ
    (29) logic_op -> . NOT_EQ
    (30) logic_op -> . GREATER
    (31) logic_op -> . GREATER_EQ
    (32) logic_op -> . LESS
    (33) logic_op -> . LESS_EQ

    EQ              shift and go to state 84
    NOT_EQ          shift and go to state 86
    GREATER         shift and go to state 82
    GREATER_EQ      shift and go to state 85
    LESS            shift and go to state 83
    LESS_EQ         shift and go to state 80

    logic_op                       shift and go to state 81

state 71

    (51) print -> WRITELN LPAREN type . RPAREN SEMICOLON

    RPAREN          shift and go to state 87


state 72

    (23) assigned -> ID ASSIGN type . SEMICOLON

    SEMICOLON       shift and go to state 88


state 73

    (22) call -> ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 89


state 74

    (25) if -> IF LPAREN statement . RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> IF LPAREN statement . RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE

    RPAREN          shift and go to state 90


state 75

    (55) gets -> GET_BOOL .

    COMMA           reduce using rule 55 (gets -> GET_BOOL .)


state 76

    (54) gets -> GET_STRING .

    COMMA           reduce using rule 54 (gets -> GET_STRING .)


state 77

    (53) gets -> GET_INT .

    COMMA           reduce using rule 53 (gets -> GET_INT .)


state 78

    (52) get -> READF LPAREN gets . COMMA AMPERSAND ID RPAREN SEMICOLON

    COMMA           shift and go to state 91


state 79

    (24) while -> WHILE LPAREN statement RPAREN . LBRACE new_scope expressions RBRACE

    LBRACE          shift and go to state 92


state 80

    (33) logic_op -> LESS_EQ .

    NUMBER          reduce using rule 33 (logic_op -> LESS_EQ .)
    STRING          reduce using rule 33 (logic_op -> LESS_EQ .)
    ID              reduce using rule 33 (logic_op -> LESS_EQ .)
    TRUE            reduce using rule 33 (logic_op -> LESS_EQ .)
    FALSE           reduce using rule 33 (logic_op -> LESS_EQ .)


state 81

    (27) statement -> type logic_op . type
    (40) type -> . NUMBER
    (41) type -> . STRING
    (42) type -> . boolean
    (43) type -> . ID
    (44) boolean -> . TRUE
    (45) boolean -> . FALSE

    NUMBER          shift and go to state 33
    STRING          shift and go to state 31
    ID              shift and go to state 36
    TRUE            shift and go to state 32
    FALSE           shift and go to state 30

    boolean                        shift and go to state 34
    type                           shift and go to state 93

state 82

    (30) logic_op -> GREATER .

    NUMBER          reduce using rule 30 (logic_op -> GREATER .)
    STRING          reduce using rule 30 (logic_op -> GREATER .)
    ID              reduce using rule 30 (logic_op -> GREATER .)
    TRUE            reduce using rule 30 (logic_op -> GREATER .)
    FALSE           reduce using rule 30 (logic_op -> GREATER .)


state 83

    (32) logic_op -> LESS .

    NUMBER          reduce using rule 32 (logic_op -> LESS .)
    STRING          reduce using rule 32 (logic_op -> LESS .)
    ID              reduce using rule 32 (logic_op -> LESS .)
    TRUE            reduce using rule 32 (logic_op -> LESS .)
    FALSE           reduce using rule 32 (logic_op -> LESS .)


state 84

    (28) logic_op -> EQ .

    NUMBER          reduce using rule 28 (logic_op -> EQ .)
    STRING          reduce using rule 28 (logic_op -> EQ .)
    ID              reduce using rule 28 (logic_op -> EQ .)
    TRUE            reduce using rule 28 (logic_op -> EQ .)
    FALSE           reduce using rule 28 (logic_op -> EQ .)


state 85

    (31) logic_op -> GREATER_EQ .

    NUMBER          reduce using rule 31 (logic_op -> GREATER_EQ .)
    STRING          reduce using rule 31 (logic_op -> GREATER_EQ .)
    ID              reduce using rule 31 (logic_op -> GREATER_EQ .)
    TRUE            reduce using rule 31 (logic_op -> GREATER_EQ .)
    FALSE           reduce using rule 31 (logic_op -> GREATER_EQ .)


state 86

    (29) logic_op -> NOT_EQ .

    NUMBER          reduce using rule 29 (logic_op -> NOT_EQ .)
    STRING          reduce using rule 29 (logic_op -> NOT_EQ .)
    ID              reduce using rule 29 (logic_op -> NOT_EQ .)
    TRUE            reduce using rule 29 (logic_op -> NOT_EQ .)
    FALSE           reduce using rule 29 (logic_op -> NOT_EQ .)


state 87

    (51) print -> WRITELN LPAREN type RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 94


state 88

    (23) assigned -> ID ASSIGN type SEMICOLON .

    RBRACE          reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    WHILE           reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    IF              reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    ID              reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    WRITELN         reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    READF           reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    ENUM            reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    INT             reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    STR             reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)
    BOOL            reduce using rule 23 (assigned -> ID ASSIGN type SEMICOLON .)


state 89

    (22) call -> ID LPAREN RPAREN SEMICOLON .

    RBRACE          reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    WRITELN         reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    READF           reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    ENUM            reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    STR             reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 22 (call -> ID LPAREN RPAREN SEMICOLON .)


state 90

    (25) if -> IF LPAREN statement RPAREN . LBRACE new_scope expressions RBRACE
    (26) if -> IF LPAREN statement RPAREN . LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE

    LBRACE          shift and go to state 95


state 91

    (52) get -> READF LPAREN gets COMMA . AMPERSAND ID RPAREN SEMICOLON

    AMPERSAND       shift and go to state 96


state 92

    (24) while -> WHILE LPAREN statement RPAREN LBRACE . new_scope expressions RBRACE
    (57) new_scope -> . empty
    (56) empty -> .

    WHILE           reduce using rule 56 (empty -> .)
    IF              reduce using rule 56 (empty -> .)
    ID              reduce using rule 56 (empty -> .)
    WRITELN         reduce using rule 56 (empty -> .)
    READF           reduce using rule 56 (empty -> .)
    ENUM            reduce using rule 56 (empty -> .)
    INT             reduce using rule 56 (empty -> .)
    STR             reduce using rule 56 (empty -> .)
    BOOL            reduce using rule 56 (empty -> .)

    new_scope                      shift and go to state 97
    empty                          shift and go to state 7

state 93

    (27) statement -> type logic_op type .

    RPAREN          reduce using rule 27 (statement -> type logic_op type .)


state 94

    (51) print -> WRITELN LPAREN type RPAREN SEMICOLON .

    RBRACE          reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    WHILE           reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    IF              reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    ID              reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    WRITELN         reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    READF           reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    ENUM            reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    INT             reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    STR             reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    BOOL            reduce using rule 51 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)


state 95

    (25) if -> IF LPAREN statement RPAREN LBRACE . new_scope expressions RBRACE
    (26) if -> IF LPAREN statement RPAREN LBRACE . new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (57) new_scope -> . empty
    (56) empty -> .

    WHILE           reduce using rule 56 (empty -> .)
    IF              reduce using rule 56 (empty -> .)
    ID              reduce using rule 56 (empty -> .)
    WRITELN         reduce using rule 56 (empty -> .)
    READF           reduce using rule 56 (empty -> .)
    ENUM            reduce using rule 56 (empty -> .)
    INT             reduce using rule 56 (empty -> .)
    STR             reduce using rule 56 (empty -> .)
    BOOL            reduce using rule 56 (empty -> .)

    new_scope                      shift and go to state 98
    empty                          shift and go to state 7

state 96

    (52) get -> READF LPAREN gets COMMA AMPERSAND . ID RPAREN SEMICOLON

    ID              shift and go to state 99


state 97

    (24) while -> WHILE LPAREN statement RPAREN LBRACE new_scope . expressions RBRACE
    (13) expressions -> . expressions expression
    (14) expressions -> . expression
    (15) expression -> . constants
    (16) expression -> . while
    (17) expression -> . if
    (18) expression -> . assigned
    (19) expression -> . print
    (20) expression -> . get
    (21) expression -> . call
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (24) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (25) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) assigned -> . ID ASSIGN type SEMICOLON
    (51) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (52) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (22) call -> . ID LPAREN RPAREN SEMICOLON
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

    WHILE           shift and go to state 47
    IF              shift and go to state 57
    ID              shift and go to state 55
    WRITELN         shift and go to state 54
    READF           shift and go to state 58
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 53
    assigned                       shift and go to state 46
    variable                       shift and go to state 10
    while                          shift and go to state 59
    call                           shift and go to state 51
    print                          shift and go to state 50
    expressions                    shift and go to state 100
    expression                     shift and go to state 60
    constants                      shift and go to state 56
    if                             shift and go to state 49

state 98

    (25) if -> IF LPAREN statement RPAREN LBRACE new_scope . expressions RBRACE
    (26) if -> IF LPAREN statement RPAREN LBRACE new_scope . expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (13) expressions -> . expressions expression
    (14) expressions -> . expression
    (15) expression -> . constants
    (16) expression -> . while
    (17) expression -> . if
    (18) expression -> . assigned
    (19) expression -> . print
    (20) expression -> . get
    (21) expression -> . call
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (24) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (25) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) assigned -> . ID ASSIGN type SEMICOLON
    (51) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (52) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (22) call -> . ID LPAREN RPAREN SEMICOLON
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

    WHILE           shift and go to state 47
    IF              shift and go to state 57
    ID              shift and go to state 55
    WRITELN         shift and go to state 54
    READF           shift and go to state 58
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 53
    assigned                       shift and go to state 46
    variable                       shift and go to state 10
    while                          shift and go to state 59
    call                           shift and go to state 51
    print                          shift and go to state 50
    expressions                    shift and go to state 101
    expression                     shift and go to state 60
    constants                      shift and go to state 56
    if                             shift and go to state 49

state 99

    (52) get -> READF LPAREN gets COMMA AMPERSAND ID . RPAREN SEMICOLON

    RPAREN          shift and go to state 102


state 100

    (24) while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions . RBRACE
    (13) expressions -> expressions . expression
    (15) expression -> . constants
    (16) expression -> . while
    (17) expression -> . if
    (18) expression -> . assigned
    (19) expression -> . print
    (20) expression -> . get
    (21) expression -> . call
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (24) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (25) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) assigned -> . ID ASSIGN type SEMICOLON
    (51) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (52) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (22) call -> . ID LPAREN RPAREN SEMICOLON
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

    RBRACE          shift and go to state 103
    WHILE           shift and go to state 47
    IF              shift and go to state 57
    ID              shift and go to state 55
    WRITELN         shift and go to state 54
    READF           shift and go to state 58
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 53
    assigned                       shift and go to state 46
    variable                       shift and go to state 10
    while                          shift and go to state 59
    call                           shift and go to state 51
    print                          shift and go to state 50
    expression                     shift and go to state 63
    constants                      shift and go to state 56
    if                             shift and go to state 49

state 101

    (25) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions . RBRACE
    (26) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions . RBRACE ELSE LBRACE new_scope expressions RBRACE
    (13) expressions -> expressions . expression
    (15) expression -> . constants
    (16) expression -> . while
    (17) expression -> . if
    (18) expression -> . assigned
    (19) expression -> . print
    (20) expression -> . get
    (21) expression -> . call
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (24) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (25) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) assigned -> . ID ASSIGN type SEMICOLON
    (51) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (52) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (22) call -> . ID LPAREN RPAREN SEMICOLON
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

    RBRACE          shift and go to state 104
    WHILE           shift and go to state 47
    IF              shift and go to state 57
    ID              shift and go to state 55
    WRITELN         shift and go to state 54
    READF           shift and go to state 58
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 53
    assigned                       shift and go to state 46
    variable                       shift and go to state 10
    while                          shift and go to state 59
    call                           shift and go to state 51
    print                          shift and go to state 50
    expression                     shift and go to state 63
    constants                      shift and go to state 56
    if                             shift and go to state 49

state 102

    (52) get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 105


state 103

    (24) while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .

    RBRACE          reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    WHILE           reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    IF              reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ID              reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    WRITELN         reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    READF           reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ENUM            reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    INT             reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    STR             reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    BOOL            reduce using rule 24 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)


state 104

    (25) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .
    (26) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE . ELSE LBRACE new_scope expressions RBRACE

    RBRACE          reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    WHILE           reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    IF              reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ID              reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    WRITELN         reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    READF           reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ENUM            reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    INT             reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    STR             reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    BOOL            reduce using rule 25 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ELSE            shift and go to state 106


state 105

    (52) get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .

    RBRACE          reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    WHILE           reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    IF              reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    ID              reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    WRITELN         reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    READF           reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    ENUM            reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    INT             reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    STR             reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    BOOL            reduce using rule 52 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)


state 106

    (26) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE . LBRACE new_scope expressions RBRACE

    LBRACE          shift and go to state 107


state 107

    (26) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE . new_scope expressions RBRACE
    (57) new_scope -> . empty
    (56) empty -> .

    WHILE           reduce using rule 56 (empty -> .)
    IF              reduce using rule 56 (empty -> .)
    ID              reduce using rule 56 (empty -> .)
    WRITELN         reduce using rule 56 (empty -> .)
    READF           reduce using rule 56 (empty -> .)
    ENUM            reduce using rule 56 (empty -> .)
    INT             reduce using rule 56 (empty -> .)
    STR             reduce using rule 56 (empty -> .)
    BOOL            reduce using rule 56 (empty -> .)

    new_scope                      shift and go to state 108
    empty                          shift and go to state 7

state 108

    (26) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope . expressions RBRACE
    (13) expressions -> . expressions expression
    (14) expressions -> . expression
    (15) expression -> . constants
    (16) expression -> . while
    (17) expression -> . if
    (18) expression -> . assigned
    (19) expression -> . print
    (20) expression -> . get
    (21) expression -> . call
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (24) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (25) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) assigned -> . ID ASSIGN type SEMICOLON
    (51) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (52) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (22) call -> . ID LPAREN RPAREN SEMICOLON
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

    WHILE           shift and go to state 47
    IF              shift and go to state 57
    ID              shift and go to state 55
    WRITELN         shift and go to state 54
    READF           shift and go to state 58
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 53
    assigned                       shift and go to state 46
    variable                       shift and go to state 10
    while                          shift and go to state 59
    call                           shift and go to state 51
    print                          shift and go to state 50
    expressions                    shift and go to state 109
    expression                     shift and go to state 60
    constants                      shift and go to state 56
    if                             shift and go to state 49

state 109

    (26) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions . RBRACE
    (13) expressions -> expressions . expression
    (15) expression -> . constants
    (16) expression -> . while
    (17) expression -> . if
    (18) expression -> . assigned
    (19) expression -> . print
    (20) expression -> . get
    (21) expression -> . call
    (46) constants -> . constants constant
    (47) constants -> . constants variable
    (48) constants -> . constant
    (49) constants -> . variable
    (24) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (25) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (26) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) assigned -> . ID ASSIGN type SEMICOLON
    (51) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (52) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (22) call -> . ID LPAREN RPAREN SEMICOLON
    (50) constant -> . ENUM init SEMICOLON
    (34) variable -> . var_type init SEMICOLON
    (37) var_type -> . INT
    (38) var_type -> . STR
    (39) var_type -> . BOOL

    RBRACE          shift and go to state 110
    WHILE           shift and go to state 47
    IF              shift and go to state 57
    ID              shift and go to state 55
    WRITELN         shift and go to state 54
    READF           shift and go to state 58
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 15

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 53
    assigned                       shift and go to state 46
    variable                       shift and go to state 10
    while                          shift and go to state 59
    call                           shift and go to state 51
    print                          shift and go to state 50
    expression                     shift and go to state 63
    constants                      shift and go to state 56
    if                             shift and go to state 49

state 110

    (26) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .

    RBRACE          reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    WHILE           reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    IF              reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    ID              reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    WRITELN         reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    READF           reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    ENUM            reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    INT             reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    STR             reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    BOOL            reduce using rule 26 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ENUM in state 11 resolved as shift
WARNING: shift/reduce conflict for INT in state 11 resolved as shift
WARNING: shift/reduce conflict for STR in state 11 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 11 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 24 resolved as shift
WARNING: shift/reduce conflict for INT in state 24 resolved as shift
WARNING: shift/reduce conflict for STR in state 24 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 24 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 56 resolved as shift
WARNING: shift/reduce conflict for INT in state 56 resolved as shift
WARNING: shift/reduce conflict for STR in state 56 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 56 resolved as shift
WARNING: reduce/reduce conflict in state 4 resolved using rule (expr -> functions)
WARNING: rejected rule (empty -> <empty>) in state 4
WARNING: reduce/reduce conflict in state 11 resolved using rule (expr -> constants)
WARNING: rejected rule (empty -> <empty>) in state 11
