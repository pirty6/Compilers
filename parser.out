Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> functions
Rule 2     start -> constants functions
Rule 3     functions -> functions function
Rule 4     functions -> function
Rule 5     function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
Rule 6     function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
Rule 7     params -> STR LSQUARE RSQUARE ID
Rule 8     params -> empty
Rule 9     expressions -> expressions expression
Rule 10    expressions -> expression
Rule 11    expression -> constants
Rule 12    expression -> while
Rule 13    expression -> if
Rule 14    expression -> assigned
Rule 15    expression -> print
Rule 16    expression -> get
Rule 17    expression -> call
Rule 18    call -> ID LPAREN RPAREN SEMICOLON
Rule 19    assigned -> ID ASSIGN type SEMICOLON
Rule 20    while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
Rule 21    if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
Rule 22    if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
Rule 23    statement -> type logic_op type
Rule 24    logic_op -> EQ
Rule 25    logic_op -> NOT_EQ
Rule 26    logic_op -> GREATER
Rule 27    logic_op -> GREATER_EQ
Rule 28    logic_op -> LESS
Rule 29    logic_op -> LESS_EQ
Rule 30    variable -> var_type init SEMICOLON
Rule 31    init -> ID ASSIGN type
Rule 32    init -> ID
Rule 33    var_type -> INT
Rule 34    var_type -> STR
Rule 35    var_type -> BOOL
Rule 36    type -> NUMBER
Rule 37    type -> STRING
Rule 38    type -> boolean
Rule 39    type -> ID
Rule 40    boolean -> TRUE
Rule 41    boolean -> FALSE
Rule 42    constants -> constants constant
Rule 43    constants -> constants variable
Rule 44    constants -> constant
Rule 45    constants -> variable
Rule 46    constant -> ENUM init SEMICOLON
Rule 47    print -> WRITELN LPAREN type RPAREN SEMICOLON
Rule 48    get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
Rule 49    gets -> GET_INT
Rule 50    gets -> GET_STRING
Rule 51    gets -> GET_BOOL
Rule 52    empty -> <empty>
Rule 53    new_scope -> empty

Terminals, with rules where they appear

AMPERSAND            : 48
ASSIGN               : 19 31
BOOL                 : 35
COMMA                : 48
ELSE                 : 22
ENUM                 : 46
EQ                   : 24
FALSE                : 41
GET_BOOL             : 51
GET_INT              : 49
GET_STRING           : 50
GREATER              : 26
GREATER_EQ           : 27
ID                   : 5 6 7 18 19 31 32 39 48
IF                   : 21 22
INT                  : 33
LBRACE               : 5 6 20 21 22 22
LESS                 : 28
LESS_EQ              : 29
LPAREN               : 5 6 18 20 21 22 47 48
LSQUARE              : 7
NOT_EQ               : 25
NUMBER               : 36
RBRACE               : 5 6 20 21 22 22
READF                : 48
RPAREN               : 5 6 18 20 21 22 47 48
RSQUARE              : 7
SEMICOLON            : 18 19 30 46 47 48
STR                  : 7 34
STRING               : 37
TRUE                 : 40
VOID                 : 5 6
WHILE                : 20
WRITELN              : 47
error                : 

Nonterminals, with rules where they appear

assigned             : 14
boolean              : 38
call                 : 17
constant             : 42 44
constants            : 2 11 42 43
empty                : 8 53
expression           : 9 10
expressions          : 5 9 20 21 22 22
function             : 3 4
functions            : 1 2 3
get                  : 16
gets                 : 48
if                   : 13
init                 : 30 46
logic_op             : 23
new_scope            : 5 6 20 21 22 22
params               : 5 6
print                : 15
start                : 0
statement            : 20 21 22
type                 : 19 23 23 31 47
var_type             : 30
variable             : 43 45
while                : 12

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . functions
    (2) start -> . constants functions
    (3) functions -> . functions function
    (4) functions -> . function
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (5) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (6) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (53) new_scope -> . empty
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL
    (52) empty -> .

    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13
    VOID            reduce using rule 52 (empty -> .)

    function                       shift and go to state 8
    functions                      shift and go to state 4
    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    new_scope                      shift and go to state 5
    start                          shift and go to state 6
    empty                          shift and go to state 7
    variable                       shift and go to state 10
    constants                      shift and go to state 11

state 1

    (44) constants -> constant .

    ENUM            reduce using rule 44 (constants -> constant .)
    INT             reduce using rule 44 (constants -> constant .)
    STR             reduce using rule 44 (constants -> constant .)
    BOOL            reduce using rule 44 (constants -> constant .)
    RBRACE          reduce using rule 44 (constants -> constant .)
    WHILE           reduce using rule 44 (constants -> constant .)
    IF              reduce using rule 44 (constants -> constant .)
    ID              reduce using rule 44 (constants -> constant .)
    WRITELN         reduce using rule 44 (constants -> constant .)
    READF           reduce using rule 44 (constants -> constant .)
    VOID            reduce using rule 44 (constants -> constant .)


state 2

    (34) var_type -> STR .

    ID              reduce using rule 34 (var_type -> STR .)


state 3

    (30) variable -> var_type . init SEMICOLON
    (31) init -> . ID ASSIGN type
    (32) init -> . ID

    ID              shift and go to state 14

    init                           shift and go to state 15

state 4

    (1) start -> functions .
    (3) functions -> functions . function
    (5) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (6) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (53) new_scope -> . empty
    (52) empty -> .

    $end            reduce using rule 1 (start -> functions .)
    VOID            reduce using rule 52 (empty -> .)

    function                       shift and go to state 16
    new_scope                      shift and go to state 5
    empty                          shift and go to state 7

state 5

    (5) function -> new_scope . VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (6) function -> new_scope . VOID ID LPAREN params RPAREN LBRACE RBRACE

    VOID            shift and go to state 17


state 6

    (0) S' -> start .



state 7

    (53) new_scope -> empty .

    VOID            reduce using rule 53 (new_scope -> empty .)
    WHILE           reduce using rule 53 (new_scope -> empty .)
    IF              reduce using rule 53 (new_scope -> empty .)
    ID              reduce using rule 53 (new_scope -> empty .)
    WRITELN         reduce using rule 53 (new_scope -> empty .)
    READF           reduce using rule 53 (new_scope -> empty .)
    ENUM            reduce using rule 53 (new_scope -> empty .)
    INT             reduce using rule 53 (new_scope -> empty .)
    STR             reduce using rule 53 (new_scope -> empty .)
    BOOL            reduce using rule 53 (new_scope -> empty .)


state 8

    (4) functions -> function .

    VOID            reduce using rule 4 (functions -> function .)
    $end            reduce using rule 4 (functions -> function .)


state 9

    (46) constant -> ENUM . init SEMICOLON
    (31) init -> . ID ASSIGN type
    (32) init -> . ID

    ID              shift and go to state 14

    init                           shift and go to state 18

state 10

    (45) constants -> variable .

    ENUM            reduce using rule 45 (constants -> variable .)
    INT             reduce using rule 45 (constants -> variable .)
    STR             reduce using rule 45 (constants -> variable .)
    BOOL            reduce using rule 45 (constants -> variable .)
    RBRACE          reduce using rule 45 (constants -> variable .)
    WHILE           reduce using rule 45 (constants -> variable .)
    IF              reduce using rule 45 (constants -> variable .)
    ID              reduce using rule 45 (constants -> variable .)
    WRITELN         reduce using rule 45 (constants -> variable .)
    READF           reduce using rule 45 (constants -> variable .)
    VOID            reduce using rule 45 (constants -> variable .)


state 11

    (2) start -> constants . functions
    (42) constants -> constants . constant
    (43) constants -> constants . variable
    (3) functions -> . functions function
    (4) functions -> . function
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (5) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (6) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL
    (53) new_scope -> . empty
    (52) empty -> .

    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13
    VOID            reduce using rule 52 (empty -> .)

    function                       shift and go to state 8
    functions                      shift and go to state 20
    constant                       shift and go to state 19
    var_type                       shift and go to state 3
    new_scope                      shift and go to state 5
    empty                          shift and go to state 7
    variable                       shift and go to state 21

state 12

    (33) var_type -> INT .

    ID              reduce using rule 33 (var_type -> INT .)


state 13

    (35) var_type -> BOOL .

    ID              reduce using rule 35 (var_type -> BOOL .)


state 14

    (31) init -> ID . ASSIGN type
    (32) init -> ID .

    ASSIGN          shift and go to state 22
    SEMICOLON       reduce using rule 32 (init -> ID .)


state 15

    (30) variable -> var_type init . SEMICOLON

    SEMICOLON       shift and go to state 23


state 16

    (3) functions -> functions function .

    VOID            reduce using rule 3 (functions -> functions function .)
    $end            reduce using rule 3 (functions -> functions function .)


state 17

    (5) function -> new_scope VOID . ID LPAREN params RPAREN LBRACE expressions RBRACE
    (6) function -> new_scope VOID . ID LPAREN params RPAREN LBRACE RBRACE

    ID              shift and go to state 24


state 18

    (46) constant -> ENUM init . SEMICOLON

    SEMICOLON       shift and go to state 25


state 19

    (42) constants -> constants constant .

    ENUM            reduce using rule 42 (constants -> constants constant .)
    INT             reduce using rule 42 (constants -> constants constant .)
    STR             reduce using rule 42 (constants -> constants constant .)
    BOOL            reduce using rule 42 (constants -> constants constant .)
    RBRACE          reduce using rule 42 (constants -> constants constant .)
    WHILE           reduce using rule 42 (constants -> constants constant .)
    IF              reduce using rule 42 (constants -> constants constant .)
    ID              reduce using rule 42 (constants -> constants constant .)
    WRITELN         reduce using rule 42 (constants -> constants constant .)
    READF           reduce using rule 42 (constants -> constants constant .)
    VOID            reduce using rule 42 (constants -> constants constant .)


state 20

    (2) start -> constants functions .
    (3) functions -> functions . function
    (5) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE
    (6) function -> . new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE
    (53) new_scope -> . empty
    (52) empty -> .

    $end            reduce using rule 2 (start -> constants functions .)
    VOID            reduce using rule 52 (empty -> .)

    function                       shift and go to state 16
    new_scope                      shift and go to state 5
    empty                          shift and go to state 7

state 21

    (43) constants -> constants variable .

    ENUM            reduce using rule 43 (constants -> constants variable .)
    INT             reduce using rule 43 (constants -> constants variable .)
    STR             reduce using rule 43 (constants -> constants variable .)
    BOOL            reduce using rule 43 (constants -> constants variable .)
    RBRACE          reduce using rule 43 (constants -> constants variable .)
    WHILE           reduce using rule 43 (constants -> constants variable .)
    IF              reduce using rule 43 (constants -> constants variable .)
    ID              reduce using rule 43 (constants -> constants variable .)
    WRITELN         reduce using rule 43 (constants -> constants variable .)
    READF           reduce using rule 43 (constants -> constants variable .)
    VOID            reduce using rule 43 (constants -> constants variable .)


state 22

    (31) init -> ID ASSIGN . type
    (36) type -> . NUMBER
    (37) type -> . STRING
    (38) type -> . boolean
    (39) type -> . ID
    (40) boolean -> . TRUE
    (41) boolean -> . FALSE

    NUMBER          shift and go to state 29
    STRING          shift and go to state 27
    ID              shift and go to state 32
    TRUE            shift and go to state 28
    FALSE           shift and go to state 26

    boolean                        shift and go to state 30
    type                           shift and go to state 31

state 23

    (30) variable -> var_type init SEMICOLON .

    ENUM            reduce using rule 30 (variable -> var_type init SEMICOLON .)
    INT             reduce using rule 30 (variable -> var_type init SEMICOLON .)
    STR             reduce using rule 30 (variable -> var_type init SEMICOLON .)
    BOOL            reduce using rule 30 (variable -> var_type init SEMICOLON .)
    RBRACE          reduce using rule 30 (variable -> var_type init SEMICOLON .)
    WHILE           reduce using rule 30 (variable -> var_type init SEMICOLON .)
    IF              reduce using rule 30 (variable -> var_type init SEMICOLON .)
    ID              reduce using rule 30 (variable -> var_type init SEMICOLON .)
    WRITELN         reduce using rule 30 (variable -> var_type init SEMICOLON .)
    READF           reduce using rule 30 (variable -> var_type init SEMICOLON .)
    VOID            reduce using rule 30 (variable -> var_type init SEMICOLON .)


state 24

    (5) function -> new_scope VOID ID . LPAREN params RPAREN LBRACE expressions RBRACE
    (6) function -> new_scope VOID ID . LPAREN params RPAREN LBRACE RBRACE

    LPAREN          shift and go to state 33


state 25

    (46) constant -> ENUM init SEMICOLON .

    ENUM            reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    INT             reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    STR             reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    BOOL            reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    VOID            reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    RBRACE          reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    WHILE           reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    IF              reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    ID              reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    WRITELN         reduce using rule 46 (constant -> ENUM init SEMICOLON .)
    READF           reduce using rule 46 (constant -> ENUM init SEMICOLON .)


state 26

    (41) boolean -> FALSE .

    RPAREN          reduce using rule 41 (boolean -> FALSE .)
    EQ              reduce using rule 41 (boolean -> FALSE .)
    NOT_EQ          reduce using rule 41 (boolean -> FALSE .)
    GREATER         reduce using rule 41 (boolean -> FALSE .)
    GREATER_EQ      reduce using rule 41 (boolean -> FALSE .)
    LESS            reduce using rule 41 (boolean -> FALSE .)
    LESS_EQ         reduce using rule 41 (boolean -> FALSE .)
    SEMICOLON       reduce using rule 41 (boolean -> FALSE .)


state 27

    (37) type -> STRING .

    RPAREN          reduce using rule 37 (type -> STRING .)
    SEMICOLON       reduce using rule 37 (type -> STRING .)
    EQ              reduce using rule 37 (type -> STRING .)
    NOT_EQ          reduce using rule 37 (type -> STRING .)
    GREATER         reduce using rule 37 (type -> STRING .)
    GREATER_EQ      reduce using rule 37 (type -> STRING .)
    LESS            reduce using rule 37 (type -> STRING .)
    LESS_EQ         reduce using rule 37 (type -> STRING .)


state 28

    (40) boolean -> TRUE .

    RPAREN          reduce using rule 40 (boolean -> TRUE .)
    EQ              reduce using rule 40 (boolean -> TRUE .)
    NOT_EQ          reduce using rule 40 (boolean -> TRUE .)
    GREATER         reduce using rule 40 (boolean -> TRUE .)
    GREATER_EQ      reduce using rule 40 (boolean -> TRUE .)
    LESS            reduce using rule 40 (boolean -> TRUE .)
    LESS_EQ         reduce using rule 40 (boolean -> TRUE .)
    SEMICOLON       reduce using rule 40 (boolean -> TRUE .)


state 29

    (36) type -> NUMBER .

    RPAREN          reduce using rule 36 (type -> NUMBER .)
    SEMICOLON       reduce using rule 36 (type -> NUMBER .)
    EQ              reduce using rule 36 (type -> NUMBER .)
    NOT_EQ          reduce using rule 36 (type -> NUMBER .)
    GREATER         reduce using rule 36 (type -> NUMBER .)
    GREATER_EQ      reduce using rule 36 (type -> NUMBER .)
    LESS            reduce using rule 36 (type -> NUMBER .)
    LESS_EQ         reduce using rule 36 (type -> NUMBER .)


state 30

    (38) type -> boolean .

    RPAREN          reduce using rule 38 (type -> boolean .)
    SEMICOLON       reduce using rule 38 (type -> boolean .)
    EQ              reduce using rule 38 (type -> boolean .)
    NOT_EQ          reduce using rule 38 (type -> boolean .)
    GREATER         reduce using rule 38 (type -> boolean .)
    GREATER_EQ      reduce using rule 38 (type -> boolean .)
    LESS            reduce using rule 38 (type -> boolean .)
    LESS_EQ         reduce using rule 38 (type -> boolean .)


state 31

    (31) init -> ID ASSIGN type .

    SEMICOLON       reduce using rule 31 (init -> ID ASSIGN type .)


state 32

    (39) type -> ID .

    RPAREN          reduce using rule 39 (type -> ID .)
    SEMICOLON       reduce using rule 39 (type -> ID .)
    EQ              reduce using rule 39 (type -> ID .)
    NOT_EQ          reduce using rule 39 (type -> ID .)
    GREATER         reduce using rule 39 (type -> ID .)
    GREATER_EQ      reduce using rule 39 (type -> ID .)
    LESS            reduce using rule 39 (type -> ID .)
    LESS_EQ         reduce using rule 39 (type -> ID .)


state 33

    (5) function -> new_scope VOID ID LPAREN . params RPAREN LBRACE expressions RBRACE
    (6) function -> new_scope VOID ID LPAREN . params RPAREN LBRACE RBRACE
    (7) params -> . STR LSQUARE RSQUARE ID
    (8) params -> . empty
    (52) empty -> .

    STR             shift and go to state 34
    RPAREN          reduce using rule 52 (empty -> .)

    params                         shift and go to state 35
    empty                          shift and go to state 36

state 34

    (7) params -> STR . LSQUARE RSQUARE ID

    LSQUARE         shift and go to state 37


state 35

    (5) function -> new_scope VOID ID LPAREN params . RPAREN LBRACE expressions RBRACE
    (6) function -> new_scope VOID ID LPAREN params . RPAREN LBRACE RBRACE

    RPAREN          shift and go to state 38


state 36

    (8) params -> empty .

    RPAREN          reduce using rule 8 (params -> empty .)


state 37

    (7) params -> STR LSQUARE . RSQUARE ID

    RSQUARE         shift and go to state 39


state 38

    (5) function -> new_scope VOID ID LPAREN params RPAREN . LBRACE expressions RBRACE
    (6) function -> new_scope VOID ID LPAREN params RPAREN . LBRACE RBRACE

    LBRACE          shift and go to state 40


state 39

    (7) params -> STR LSQUARE RSQUARE . ID

    ID              shift and go to state 41


state 40

    (5) function -> new_scope VOID ID LPAREN params RPAREN LBRACE . expressions RBRACE
    (6) function -> new_scope VOID ID LPAREN params RPAREN LBRACE . RBRACE
    (9) expressions -> . expressions expression
    (10) expressions -> . expression
    (11) expression -> . constants
    (12) expression -> . while
    (13) expression -> . if
    (14) expression -> . assigned
    (15) expression -> . print
    (16) expression -> . get
    (17) expression -> . call
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (20) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (21) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (19) assigned -> . ID ASSIGN type SEMICOLON
    (47) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (48) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (18) call -> . ID LPAREN RPAREN SEMICOLON
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

    RBRACE          shift and go to state 48
    WHILE           shift and go to state 43
    IF              shift and go to state 53
    ID              shift and go to state 51
    WRITELN         shift and go to state 50
    READF           shift and go to state 54
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 49
    assigned                       shift and go to state 42
    variable                       shift and go to state 10
    while                          shift and go to state 55
    print                          shift and go to state 46
    call                           shift and go to state 47
    expressions                    shift and go to state 44
    expression                     shift and go to state 56
    constants                      shift and go to state 52
    if                             shift and go to state 45

state 41

    (7) params -> STR LSQUARE RSQUARE ID .

    RPAREN          reduce using rule 7 (params -> STR LSQUARE RSQUARE ID .)


state 42

    (14) expression -> assigned .

    RBRACE          reduce using rule 14 (expression -> assigned .)
    WHILE           reduce using rule 14 (expression -> assigned .)
    IF              reduce using rule 14 (expression -> assigned .)
    ID              reduce using rule 14 (expression -> assigned .)
    WRITELN         reduce using rule 14 (expression -> assigned .)
    READF           reduce using rule 14 (expression -> assigned .)
    ENUM            reduce using rule 14 (expression -> assigned .)
    INT             reduce using rule 14 (expression -> assigned .)
    STR             reduce using rule 14 (expression -> assigned .)
    BOOL            reduce using rule 14 (expression -> assigned .)


state 43

    (20) while -> WHILE . LPAREN statement RPAREN LBRACE new_scope expressions RBRACE

    LPAREN          shift and go to state 57


state 44

    (5) function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions . RBRACE
    (9) expressions -> expressions . expression
    (11) expression -> . constants
    (12) expression -> . while
    (13) expression -> . if
    (14) expression -> . assigned
    (15) expression -> . print
    (16) expression -> . get
    (17) expression -> . call
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (20) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (21) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (19) assigned -> . ID ASSIGN type SEMICOLON
    (47) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (48) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (18) call -> . ID LPAREN RPAREN SEMICOLON
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

    RBRACE          shift and go to state 58
    WHILE           shift and go to state 43
    IF              shift and go to state 53
    ID              shift and go to state 51
    WRITELN         shift and go to state 50
    READF           shift and go to state 54
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 49
    assigned                       shift and go to state 42
    variable                       shift and go to state 10
    while                          shift and go to state 55
    print                          shift and go to state 46
    call                           shift and go to state 47
    expression                     shift and go to state 59
    constants                      shift and go to state 52
    if                             shift and go to state 45

state 45

    (13) expression -> if .

    RBRACE          reduce using rule 13 (expression -> if .)
    WHILE           reduce using rule 13 (expression -> if .)
    IF              reduce using rule 13 (expression -> if .)
    ID              reduce using rule 13 (expression -> if .)
    WRITELN         reduce using rule 13 (expression -> if .)
    READF           reduce using rule 13 (expression -> if .)
    ENUM            reduce using rule 13 (expression -> if .)
    INT             reduce using rule 13 (expression -> if .)
    STR             reduce using rule 13 (expression -> if .)
    BOOL            reduce using rule 13 (expression -> if .)


state 46

    (15) expression -> print .

    RBRACE          reduce using rule 15 (expression -> print .)
    WHILE           reduce using rule 15 (expression -> print .)
    IF              reduce using rule 15 (expression -> print .)
    ID              reduce using rule 15 (expression -> print .)
    WRITELN         reduce using rule 15 (expression -> print .)
    READF           reduce using rule 15 (expression -> print .)
    ENUM            reduce using rule 15 (expression -> print .)
    INT             reduce using rule 15 (expression -> print .)
    STR             reduce using rule 15 (expression -> print .)
    BOOL            reduce using rule 15 (expression -> print .)


state 47

    (17) expression -> call .

    RBRACE          reduce using rule 17 (expression -> call .)
    WHILE           reduce using rule 17 (expression -> call .)
    IF              reduce using rule 17 (expression -> call .)
    ID              reduce using rule 17 (expression -> call .)
    WRITELN         reduce using rule 17 (expression -> call .)
    READF           reduce using rule 17 (expression -> call .)
    ENUM            reduce using rule 17 (expression -> call .)
    INT             reduce using rule 17 (expression -> call .)
    STR             reduce using rule 17 (expression -> call .)
    BOOL            reduce using rule 17 (expression -> call .)


state 48

    (6) function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .

    VOID            reduce using rule 6 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .)
    $end            reduce using rule 6 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE RBRACE .)


state 49

    (16) expression -> get .

    RBRACE          reduce using rule 16 (expression -> get .)
    WHILE           reduce using rule 16 (expression -> get .)
    IF              reduce using rule 16 (expression -> get .)
    ID              reduce using rule 16 (expression -> get .)
    WRITELN         reduce using rule 16 (expression -> get .)
    READF           reduce using rule 16 (expression -> get .)
    ENUM            reduce using rule 16 (expression -> get .)
    INT             reduce using rule 16 (expression -> get .)
    STR             reduce using rule 16 (expression -> get .)
    BOOL            reduce using rule 16 (expression -> get .)


state 50

    (47) print -> WRITELN . LPAREN type RPAREN SEMICOLON

    LPAREN          shift and go to state 60


state 51

    (19) assigned -> ID . ASSIGN type SEMICOLON
    (18) call -> ID . LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 61
    LPAREN          shift and go to state 62


state 52

    (11) expression -> constants .
    (42) constants -> constants . constant
    (43) constants -> constants . variable
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for STR resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
    RBRACE          reduce using rule 11 (expression -> constants .)
    WHILE           reduce using rule 11 (expression -> constants .)
    IF              reduce using rule 11 (expression -> constants .)
    ID              reduce using rule 11 (expression -> constants .)
    WRITELN         reduce using rule 11 (expression -> constants .)
    READF           reduce using rule 11 (expression -> constants .)
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

  ! ENUM            [ reduce using rule 11 (expression -> constants .) ]
  ! INT             [ reduce using rule 11 (expression -> constants .) ]
  ! STR             [ reduce using rule 11 (expression -> constants .) ]
  ! BOOL            [ reduce using rule 11 (expression -> constants .) ]

    variable                       shift and go to state 21
    constant                       shift and go to state 19
    var_type                       shift and go to state 3

state 53

    (21) if -> IF . LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> IF . LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE

    LPAREN          shift and go to state 63


state 54

    (48) get -> READF . LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON

    LPAREN          shift and go to state 64


state 55

    (12) expression -> while .

    RBRACE          reduce using rule 12 (expression -> while .)
    WHILE           reduce using rule 12 (expression -> while .)
    IF              reduce using rule 12 (expression -> while .)
    ID              reduce using rule 12 (expression -> while .)
    WRITELN         reduce using rule 12 (expression -> while .)
    READF           reduce using rule 12 (expression -> while .)
    ENUM            reduce using rule 12 (expression -> while .)
    INT             reduce using rule 12 (expression -> while .)
    STR             reduce using rule 12 (expression -> while .)
    BOOL            reduce using rule 12 (expression -> while .)


state 56

    (10) expressions -> expression .

    RBRACE          reduce using rule 10 (expressions -> expression .)
    WHILE           reduce using rule 10 (expressions -> expression .)
    IF              reduce using rule 10 (expressions -> expression .)
    ID              reduce using rule 10 (expressions -> expression .)
    WRITELN         reduce using rule 10 (expressions -> expression .)
    READF           reduce using rule 10 (expressions -> expression .)
    ENUM            reduce using rule 10 (expressions -> expression .)
    INT             reduce using rule 10 (expressions -> expression .)
    STR             reduce using rule 10 (expressions -> expression .)
    BOOL            reduce using rule 10 (expressions -> expression .)


state 57

    (20) while -> WHILE LPAREN . statement RPAREN LBRACE new_scope expressions RBRACE
    (23) statement -> . type logic_op type
    (36) type -> . NUMBER
    (37) type -> . STRING
    (38) type -> . boolean
    (39) type -> . ID
    (40) boolean -> . TRUE
    (41) boolean -> . FALSE

    NUMBER          shift and go to state 29
    STRING          shift and go to state 27
    ID              shift and go to state 32
    TRUE            shift and go to state 28
    FALSE           shift and go to state 26

    boolean                        shift and go to state 30
    statement                      shift and go to state 65
    type                           shift and go to state 66

state 58

    (5) function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .

    VOID            reduce using rule 5 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .)
    $end            reduce using rule 5 (function -> new_scope VOID ID LPAREN params RPAREN LBRACE expressions RBRACE .)


state 59

    (9) expressions -> expressions expression .

    RBRACE          reduce using rule 9 (expressions -> expressions expression .)
    WHILE           reduce using rule 9 (expressions -> expressions expression .)
    IF              reduce using rule 9 (expressions -> expressions expression .)
    ID              reduce using rule 9 (expressions -> expressions expression .)
    WRITELN         reduce using rule 9 (expressions -> expressions expression .)
    READF           reduce using rule 9 (expressions -> expressions expression .)
    ENUM            reduce using rule 9 (expressions -> expressions expression .)
    INT             reduce using rule 9 (expressions -> expressions expression .)
    STR             reduce using rule 9 (expressions -> expressions expression .)
    BOOL            reduce using rule 9 (expressions -> expressions expression .)


state 60

    (47) print -> WRITELN LPAREN . type RPAREN SEMICOLON
    (36) type -> . NUMBER
    (37) type -> . STRING
    (38) type -> . boolean
    (39) type -> . ID
    (40) boolean -> . TRUE
    (41) boolean -> . FALSE

    NUMBER          shift and go to state 29
    STRING          shift and go to state 27
    ID              shift and go to state 32
    TRUE            shift and go to state 28
    FALSE           shift and go to state 26

    boolean                        shift and go to state 30
    type                           shift and go to state 67

state 61

    (19) assigned -> ID ASSIGN . type SEMICOLON
    (36) type -> . NUMBER
    (37) type -> . STRING
    (38) type -> . boolean
    (39) type -> . ID
    (40) boolean -> . TRUE
    (41) boolean -> . FALSE

    NUMBER          shift and go to state 29
    STRING          shift and go to state 27
    ID              shift and go to state 32
    TRUE            shift and go to state 28
    FALSE           shift and go to state 26

    boolean                        shift and go to state 30
    type                           shift and go to state 68

state 62

    (18) call -> ID LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 69


state 63

    (21) if -> IF LPAREN . statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> IF LPAREN . statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (23) statement -> . type logic_op type
    (36) type -> . NUMBER
    (37) type -> . STRING
    (38) type -> . boolean
    (39) type -> . ID
    (40) boolean -> . TRUE
    (41) boolean -> . FALSE

    NUMBER          shift and go to state 29
    STRING          shift and go to state 27
    ID              shift and go to state 32
    TRUE            shift and go to state 28
    FALSE           shift and go to state 26

    boolean                        shift and go to state 30
    statement                      shift and go to state 70
    type                           shift and go to state 66

state 64

    (48) get -> READF LPAREN . gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (49) gets -> . GET_INT
    (50) gets -> . GET_STRING
    (51) gets -> . GET_BOOL

    GET_INT         shift and go to state 73
    GET_STRING      shift and go to state 72
    GET_BOOL        shift and go to state 71

    gets                           shift and go to state 74

state 65

    (20) while -> WHILE LPAREN statement . RPAREN LBRACE new_scope expressions RBRACE

    RPAREN          shift and go to state 75


state 66

    (23) statement -> type . logic_op type
    (24) logic_op -> . EQ
    (25) logic_op -> . NOT_EQ
    (26) logic_op -> . GREATER
    (27) logic_op -> . GREATER_EQ
    (28) logic_op -> . LESS
    (29) logic_op -> . LESS_EQ

    EQ              shift and go to state 80
    NOT_EQ          shift and go to state 82
    GREATER         shift and go to state 78
    GREATER_EQ      shift and go to state 81
    LESS            shift and go to state 79
    LESS_EQ         shift and go to state 76

    logic_op                       shift and go to state 77

state 67

    (47) print -> WRITELN LPAREN type . RPAREN SEMICOLON

    RPAREN          shift and go to state 83


state 68

    (19) assigned -> ID ASSIGN type . SEMICOLON

    SEMICOLON       shift and go to state 84


state 69

    (18) call -> ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 85


state 70

    (21) if -> IF LPAREN statement . RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> IF LPAREN statement . RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE

    RPAREN          shift and go to state 86


state 71

    (51) gets -> GET_BOOL .

    COMMA           reduce using rule 51 (gets -> GET_BOOL .)


state 72

    (50) gets -> GET_STRING .

    COMMA           reduce using rule 50 (gets -> GET_STRING .)


state 73

    (49) gets -> GET_INT .

    COMMA           reduce using rule 49 (gets -> GET_INT .)


state 74

    (48) get -> READF LPAREN gets . COMMA AMPERSAND ID RPAREN SEMICOLON

    COMMA           shift and go to state 87


state 75

    (20) while -> WHILE LPAREN statement RPAREN . LBRACE new_scope expressions RBRACE

    LBRACE          shift and go to state 88


state 76

    (29) logic_op -> LESS_EQ .

    NUMBER          reduce using rule 29 (logic_op -> LESS_EQ .)
    STRING          reduce using rule 29 (logic_op -> LESS_EQ .)
    ID              reduce using rule 29 (logic_op -> LESS_EQ .)
    TRUE            reduce using rule 29 (logic_op -> LESS_EQ .)
    FALSE           reduce using rule 29 (logic_op -> LESS_EQ .)


state 77

    (23) statement -> type logic_op . type
    (36) type -> . NUMBER
    (37) type -> . STRING
    (38) type -> . boolean
    (39) type -> . ID
    (40) boolean -> . TRUE
    (41) boolean -> . FALSE

    NUMBER          shift and go to state 29
    STRING          shift and go to state 27
    ID              shift and go to state 32
    TRUE            shift and go to state 28
    FALSE           shift and go to state 26

    boolean                        shift and go to state 30
    type                           shift and go to state 89

state 78

    (26) logic_op -> GREATER .

    NUMBER          reduce using rule 26 (logic_op -> GREATER .)
    STRING          reduce using rule 26 (logic_op -> GREATER .)
    ID              reduce using rule 26 (logic_op -> GREATER .)
    TRUE            reduce using rule 26 (logic_op -> GREATER .)
    FALSE           reduce using rule 26 (logic_op -> GREATER .)


state 79

    (28) logic_op -> LESS .

    NUMBER          reduce using rule 28 (logic_op -> LESS .)
    STRING          reduce using rule 28 (logic_op -> LESS .)
    ID              reduce using rule 28 (logic_op -> LESS .)
    TRUE            reduce using rule 28 (logic_op -> LESS .)
    FALSE           reduce using rule 28 (logic_op -> LESS .)


state 80

    (24) logic_op -> EQ .

    NUMBER          reduce using rule 24 (logic_op -> EQ .)
    STRING          reduce using rule 24 (logic_op -> EQ .)
    ID              reduce using rule 24 (logic_op -> EQ .)
    TRUE            reduce using rule 24 (logic_op -> EQ .)
    FALSE           reduce using rule 24 (logic_op -> EQ .)


state 81

    (27) logic_op -> GREATER_EQ .

    NUMBER          reduce using rule 27 (logic_op -> GREATER_EQ .)
    STRING          reduce using rule 27 (logic_op -> GREATER_EQ .)
    ID              reduce using rule 27 (logic_op -> GREATER_EQ .)
    TRUE            reduce using rule 27 (logic_op -> GREATER_EQ .)
    FALSE           reduce using rule 27 (logic_op -> GREATER_EQ .)


state 82

    (25) logic_op -> NOT_EQ .

    NUMBER          reduce using rule 25 (logic_op -> NOT_EQ .)
    STRING          reduce using rule 25 (logic_op -> NOT_EQ .)
    ID              reduce using rule 25 (logic_op -> NOT_EQ .)
    TRUE            reduce using rule 25 (logic_op -> NOT_EQ .)
    FALSE           reduce using rule 25 (logic_op -> NOT_EQ .)


state 83

    (47) print -> WRITELN LPAREN type RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 90


state 84

    (19) assigned -> ID ASSIGN type SEMICOLON .

    RBRACE          reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    WHILE           reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    IF              reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    ID              reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    WRITELN         reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    READF           reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    ENUM            reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    INT             reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    STR             reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)
    BOOL            reduce using rule 19 (assigned -> ID ASSIGN type SEMICOLON .)


state 85

    (18) call -> ID LPAREN RPAREN SEMICOLON .

    RBRACE          reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    WRITELN         reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    READF           reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    ENUM            reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    INT             reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    STR             reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)
    BOOL            reduce using rule 18 (call -> ID LPAREN RPAREN SEMICOLON .)


state 86

    (21) if -> IF LPAREN statement RPAREN . LBRACE new_scope expressions RBRACE
    (22) if -> IF LPAREN statement RPAREN . LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE

    LBRACE          shift and go to state 91


state 87

    (48) get -> READF LPAREN gets COMMA . AMPERSAND ID RPAREN SEMICOLON

    AMPERSAND       shift and go to state 92


state 88

    (20) while -> WHILE LPAREN statement RPAREN LBRACE . new_scope expressions RBRACE
    (53) new_scope -> . empty
    (52) empty -> .

    WHILE           reduce using rule 52 (empty -> .)
    IF              reduce using rule 52 (empty -> .)
    ID              reduce using rule 52 (empty -> .)
    WRITELN         reduce using rule 52 (empty -> .)
    READF           reduce using rule 52 (empty -> .)
    ENUM            reduce using rule 52 (empty -> .)
    INT             reduce using rule 52 (empty -> .)
    STR             reduce using rule 52 (empty -> .)
    BOOL            reduce using rule 52 (empty -> .)

    new_scope                      shift and go to state 93
    empty                          shift and go to state 7

state 89

    (23) statement -> type logic_op type .

    RPAREN          reduce using rule 23 (statement -> type logic_op type .)


state 90

    (47) print -> WRITELN LPAREN type RPAREN SEMICOLON .

    RBRACE          reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    WHILE           reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    IF              reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    ID              reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    WRITELN         reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    READF           reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    ENUM            reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    INT             reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    STR             reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)
    BOOL            reduce using rule 47 (print -> WRITELN LPAREN type RPAREN SEMICOLON .)


state 91

    (21) if -> IF LPAREN statement RPAREN LBRACE . new_scope expressions RBRACE
    (22) if -> IF LPAREN statement RPAREN LBRACE . new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (53) new_scope -> . empty
    (52) empty -> .

    WHILE           reduce using rule 52 (empty -> .)
    IF              reduce using rule 52 (empty -> .)
    ID              reduce using rule 52 (empty -> .)
    WRITELN         reduce using rule 52 (empty -> .)
    READF           reduce using rule 52 (empty -> .)
    ENUM            reduce using rule 52 (empty -> .)
    INT             reduce using rule 52 (empty -> .)
    STR             reduce using rule 52 (empty -> .)
    BOOL            reduce using rule 52 (empty -> .)

    new_scope                      shift and go to state 94
    empty                          shift and go to state 7

state 92

    (48) get -> READF LPAREN gets COMMA AMPERSAND . ID RPAREN SEMICOLON

    ID              shift and go to state 95


state 93

    (20) while -> WHILE LPAREN statement RPAREN LBRACE new_scope . expressions RBRACE
    (9) expressions -> . expressions expression
    (10) expressions -> . expression
    (11) expression -> . constants
    (12) expression -> . while
    (13) expression -> . if
    (14) expression -> . assigned
    (15) expression -> . print
    (16) expression -> . get
    (17) expression -> . call
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (20) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (21) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (19) assigned -> . ID ASSIGN type SEMICOLON
    (47) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (48) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (18) call -> . ID LPAREN RPAREN SEMICOLON
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

    WHILE           shift and go to state 43
    IF              shift and go to state 53
    ID              shift and go to state 51
    WRITELN         shift and go to state 50
    READF           shift and go to state 54
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 49
    assigned                       shift and go to state 42
    variable                       shift and go to state 10
    while                          shift and go to state 55
    call                           shift and go to state 47
    print                          shift and go to state 46
    expressions                    shift and go to state 96
    expression                     shift and go to state 56
    constants                      shift and go to state 52
    if                             shift and go to state 45

state 94

    (21) if -> IF LPAREN statement RPAREN LBRACE new_scope . expressions RBRACE
    (22) if -> IF LPAREN statement RPAREN LBRACE new_scope . expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (9) expressions -> . expressions expression
    (10) expressions -> . expression
    (11) expression -> . constants
    (12) expression -> . while
    (13) expression -> . if
    (14) expression -> . assigned
    (15) expression -> . print
    (16) expression -> . get
    (17) expression -> . call
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (20) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (21) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (19) assigned -> . ID ASSIGN type SEMICOLON
    (47) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (48) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (18) call -> . ID LPAREN RPAREN SEMICOLON
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

    WHILE           shift and go to state 43
    IF              shift and go to state 53
    ID              shift and go to state 51
    WRITELN         shift and go to state 50
    READF           shift and go to state 54
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 49
    assigned                       shift and go to state 42
    variable                       shift and go to state 10
    while                          shift and go to state 55
    call                           shift and go to state 47
    print                          shift and go to state 46
    expressions                    shift and go to state 97
    expression                     shift and go to state 56
    constants                      shift and go to state 52
    if                             shift and go to state 45

state 95

    (48) get -> READF LPAREN gets COMMA AMPERSAND ID . RPAREN SEMICOLON

    RPAREN          shift and go to state 98


state 96

    (20) while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions . RBRACE
    (9) expressions -> expressions . expression
    (11) expression -> . constants
    (12) expression -> . while
    (13) expression -> . if
    (14) expression -> . assigned
    (15) expression -> . print
    (16) expression -> . get
    (17) expression -> . call
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (20) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (21) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (19) assigned -> . ID ASSIGN type SEMICOLON
    (47) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (48) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (18) call -> . ID LPAREN RPAREN SEMICOLON
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

    RBRACE          shift and go to state 99
    WHILE           shift and go to state 43
    IF              shift and go to state 53
    ID              shift and go to state 51
    WRITELN         shift and go to state 50
    READF           shift and go to state 54
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 49
    assigned                       shift and go to state 42
    variable                       shift and go to state 10
    while                          shift and go to state 55
    call                           shift and go to state 47
    print                          shift and go to state 46
    expression                     shift and go to state 59
    constants                      shift and go to state 52
    if                             shift and go to state 45

state 97

    (21) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions . RBRACE
    (22) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions . RBRACE ELSE LBRACE new_scope expressions RBRACE
    (9) expressions -> expressions . expression
    (11) expression -> . constants
    (12) expression -> . while
    (13) expression -> . if
    (14) expression -> . assigned
    (15) expression -> . print
    (16) expression -> . get
    (17) expression -> . call
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (20) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (21) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (19) assigned -> . ID ASSIGN type SEMICOLON
    (47) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (48) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (18) call -> . ID LPAREN RPAREN SEMICOLON
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

    RBRACE          shift and go to state 100
    WHILE           shift and go to state 43
    IF              shift and go to state 53
    ID              shift and go to state 51
    WRITELN         shift and go to state 50
    READF           shift and go to state 54
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 49
    assigned                       shift and go to state 42
    variable                       shift and go to state 10
    while                          shift and go to state 55
    call                           shift and go to state 47
    print                          shift and go to state 46
    expression                     shift and go to state 59
    constants                      shift and go to state 52
    if                             shift and go to state 45

state 98

    (48) get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 101


state 99

    (20) while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .

    RBRACE          reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    WHILE           reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    IF              reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ID              reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    WRITELN         reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    READF           reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ENUM            reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    INT             reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    STR             reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    BOOL            reduce using rule 20 (while -> WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)


state 100

    (21) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .
    (22) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE . ELSE LBRACE new_scope expressions RBRACE

    RBRACE          reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    WHILE           reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    IF              reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ID              reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    WRITELN         reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    READF           reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ENUM            reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    INT             reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    STR             reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    BOOL            reduce using rule 21 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE .)
    ELSE            shift and go to state 102


state 101

    (48) get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .

    RBRACE          reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    WHILE           reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    IF              reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    ID              reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    WRITELN         reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    READF           reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    ENUM            reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    INT             reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    STR             reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)
    BOOL            reduce using rule 48 (get -> READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON .)


state 102

    (22) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE . LBRACE new_scope expressions RBRACE

    LBRACE          shift and go to state 103


state 103

    (22) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE . new_scope expressions RBRACE
    (53) new_scope -> . empty
    (52) empty -> .

    WHILE           reduce using rule 52 (empty -> .)
    IF              reduce using rule 52 (empty -> .)
    ID              reduce using rule 52 (empty -> .)
    WRITELN         reduce using rule 52 (empty -> .)
    READF           reduce using rule 52 (empty -> .)
    ENUM            reduce using rule 52 (empty -> .)
    INT             reduce using rule 52 (empty -> .)
    STR             reduce using rule 52 (empty -> .)
    BOOL            reduce using rule 52 (empty -> .)

    new_scope                      shift and go to state 104
    empty                          shift and go to state 7

state 104

    (22) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope . expressions RBRACE
    (9) expressions -> . expressions expression
    (10) expressions -> . expression
    (11) expression -> . constants
    (12) expression -> . while
    (13) expression -> . if
    (14) expression -> . assigned
    (15) expression -> . print
    (16) expression -> . get
    (17) expression -> . call
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (20) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (21) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (19) assigned -> . ID ASSIGN type SEMICOLON
    (47) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (48) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (18) call -> . ID LPAREN RPAREN SEMICOLON
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

    WHILE           shift and go to state 43
    IF              shift and go to state 53
    ID              shift and go to state 51
    WRITELN         shift and go to state 50
    READF           shift and go to state 54
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 49
    assigned                       shift and go to state 42
    variable                       shift and go to state 10
    while                          shift and go to state 55
    call                           shift and go to state 47
    print                          shift and go to state 46
    expressions                    shift and go to state 105
    expression                     shift and go to state 56
    constants                      shift and go to state 52
    if                             shift and go to state 45

state 105

    (22) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions . RBRACE
    (9) expressions -> expressions . expression
    (11) expression -> . constants
    (12) expression -> . while
    (13) expression -> . if
    (14) expression -> . assigned
    (15) expression -> . print
    (16) expression -> . get
    (17) expression -> . call
    (42) constants -> . constants constant
    (43) constants -> . constants variable
    (44) constants -> . constant
    (45) constants -> . variable
    (20) while -> . WHILE LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (21) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE
    (22) if -> . IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE
    (19) assigned -> . ID ASSIGN type SEMICOLON
    (47) print -> . WRITELN LPAREN type RPAREN SEMICOLON
    (48) get -> . READF LPAREN gets COMMA AMPERSAND ID RPAREN SEMICOLON
    (18) call -> . ID LPAREN RPAREN SEMICOLON
    (46) constant -> . ENUM init SEMICOLON
    (30) variable -> . var_type init SEMICOLON
    (33) var_type -> . INT
    (34) var_type -> . STR
    (35) var_type -> . BOOL

    RBRACE          shift and go to state 106
    WHILE           shift and go to state 43
    IF              shift and go to state 53
    ID              shift and go to state 51
    WRITELN         shift and go to state 50
    READF           shift and go to state 54
    ENUM            shift and go to state 9
    INT             shift and go to state 12
    STR             shift and go to state 2
    BOOL            shift and go to state 13

    constant                       shift and go to state 1
    var_type                       shift and go to state 3
    get                            shift and go to state 49
    assigned                       shift and go to state 42
    variable                       shift and go to state 10
    while                          shift and go to state 55
    call                           shift and go to state 47
    print                          shift and go to state 46
    expression                     shift and go to state 59
    constants                      shift and go to state 52
    if                             shift and go to state 45

state 106

    (22) if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .

    RBRACE          reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    WHILE           reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    IF              reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    ID              reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    WRITELN         reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    READF           reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    ENUM            reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    INT             reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    STR             reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)
    BOOL            reduce using rule 22 (if -> IF LPAREN statement RPAREN LBRACE new_scope expressions RBRACE ELSE LBRACE new_scope expressions RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ENUM in state 52 resolved as shift
WARNING: shift/reduce conflict for INT in state 52 resolved as shift
WARNING: shift/reduce conflict for STR in state 52 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 52 resolved as shift
